"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MiddlewareResponse = void 0;
const server_1 = require("next/server");
// A NextResponse that wraps the Netlify origin response
// We can't pass it through directly, because Next disallows returning a response body
class MiddlewareResponse extends server_1.NextResponse {
    constructor(originResponse) {
        super();
        this.originResponse = originResponse;
        // These are private in Node when compiling, but we access them in Deno at runtime
        Object.defineProperty(this, 'dataTransforms', {
            value: [],
            enumerable: false,
            writable: false,
        });
        Object.defineProperty(this, 'elementHandlers', {
            value: [],
            enumerable: false,
            writable: false,
        });
    }
    /**
     * Transform the page props before they are passed to the client.
     * This works for both HTML pages and JSON data
     */
    transformData(transform) {
        // The transforms are evaluated after the middleware is returned
        this.dataTransforms.push(transform);
    }
    /**
     * Rewrite the response HTML with the given selector and handlers
     */
    rewriteHTML(selector, handlers) {
        this.elementHandlers.push([selector, handlers]);
    }
    /**
     * Sets the value of a page prop.
     * @see transformData if you need more control
     */
    setPageProp(key, value) {
        this.transformData((props) => {
            props.pageProps || (props.pageProps = {});
            props.pageProps[key] = value;
            return props;
        });
    }
    /**
     * Replace the text of the given element. Takes either a string or a function
     * that is passed the original string and returns new new string.
     * @see rewriteHTML for more control
     */
    replaceText(selector, valueOrReplacer) {
        // If it's a string then our job is simpler, because we don't need to collect the current text
        if (typeof valueOrReplacer === 'string') {
            this.rewriteHTML(selector, {
                text(textChunk) {
                    if (textChunk.lastInTextNode) {
                        textChunk.replace(valueOrReplacer);
                    }
                    else {
                        textChunk.remove();
                    }
                },
            });
        }
        else {
            let text = '';
            this.rewriteHTML(selector, {
                text(textChunk) {
                    text += textChunk.text;
                    // We're finished, so we can replace the text
                    if (textChunk.lastInTextNode) {
                        textChunk.replace(valueOrReplacer(text));
                    }
                    else {
                        // Remove the chunk, because we'll be adding it back later
                        textChunk.remove();
                    }
                },
            });
        }
    }
    get headers() {
        var _a;
        // If we have the origin response, we should use its headers
        return ((_a = this.originResponse) === null || _a === void 0 ? void 0 : _a.headers) || super.headers;
    }
}
exports.MiddlewareResponse = MiddlewareResponse;
